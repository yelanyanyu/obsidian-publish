---
{"dg-publish":true,"permalink":"/01/03-408/01/05-01-zuo//02//","tags":["personal/blog","algorithm/sorting"]}
---


# 概述
基数排序其实是一种[[01-计算机笔记/03-408/01-数据结构/05-01-数据结构与算法-zuo/算法/02-排序算法/桶排序\|桶排序]]，利用了桶排序的容器思想，把需要比较的逻辑值放入容器中，从而比较出大小。顾名思义，基数排序是根据基数来排序的，即根据个位十位百位... 的大小关系来排序。
需要注意，桶排序并不是一种具体的排序方法，而是一类排序的总称，只要运用了桶（容器）思想的排序都叫桶排序。
在具体谈论到基数排序前，我们先从桶排序的基础实现——计数排序讲起。
***
# 计数排序
[[01-计算机笔记/03-408/01-数据结构/05-01-数据结构与算法-zuo/算法/02-排序算法/计数排序\|计数排序]]
# 基数排序
为了避免 help 数组开销过大，于是基数排序改进计数排序的逻辑，将逻辑改为以数位为标准进行比较，极大的减小了空间的浪费，同时也保留了一定的效率。
## 基数排序的基本思想
假设数据类型为十进制正整数，那么就将 help 数组开辟 10 个空间，每个空间对应一个队列；
1. 找到数据中的最大值，得到最大的位数 radix；
2. 从左到右开始遍历，把数据依次放入个位数与 help 下标对应的队列中；
3. 从左往右遍历 help，先进队列的数据先取出，放入到原数组中，此时数据按个位数从小到大排列；
4. 重新遍历原数组，这次按十位从小到大排列；
5. 按百位，千位.... ，直到按最大的位数排列完毕，此时原数组就变位有序的了；

基数排序很好的利用了高位颠覆的低位的性质，保证了高位大于低位，同时保证了高位相同时，数据的相对顺序；
## 基数排序改进
但是，对于空间的浪费仍然可以再退一步。
我们可以用两个 count 数组来模拟队列的实现——也就是模拟入桶和出桶。
以个位为例，第一个 count 数组用来统计各个个位数字出现的频次；
第二个 count’数组用来统计小于那个数（那个数=下标的值）的频次；
以 help 数组来临时存储出桶后的数据。
我们通过具体的代码实现来阐述实现排序的原理。
### 实现步骤
1. 为了能够更方便的进行高位的比较，我们在不足最高位的数据前面补 0，即在判断时默认为 0——返回每个数的 index 位，利用函数 getDigit 实现；
2. 获取数据中的最大值的位数——构建函数 maxDigit 实现；
3. 遍历原数组，将个位数的频次填入 count 数组；
4. 遍历 count 数组，执行操作 `count[i]=count[i-1]+count[i]`，统计小于频次；
5. 对原数组从右往左遍历，与原数据个位数对应的 count’的下标表示的值**映射了原数组在 help 中的排位；**
6. 按照这个映射关系将原数据放入 help 数组中，此时就是按个位升序排列的原数据；
7. 类比以上步骤对十位以及更高位进行排序；


### 代码实现
```java
public static void radixSort(int[] arr, int L, int R, int digit) {  
    if (L > R) {  
        return;  
    }  
    int i = 0;  
    int j = 0;  
    int[] help = new int[R - L + 1];  
    for (int d = 1; d <= digit; d++) {  
        int[] count = new int[10];  
        for (i = L; i <= R; i++) {    //统计词频  
            j = getDigit(arr[i], d);  
            count[j]++;  
        }  
        for (int m = 1; m < count.length; m++) {       //改写count为count’  
            count[m] = count[m] + count[m - 1];  
        }  
        for (int k = arr.length - 1; k >= 0; k--) {  
            j = getDigit(arr[k], d);  
            help[count[j] - 1] = arr[k];//出桶 //映射逻辑（1） 
            count[j]--;  
        }  
        for (int k = 0; k < R - L + 1; k++) {       //若要降序，则让help内的元素逆序输出到arr中即可  
            arr[L + k] = help[k];  
        }
    }
}
```
### 映射逻辑解读
![微信图片_20220722120342.jpg](/img/user/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AC%94%E8%AE%B0/03-408/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05-01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-zuo/%E7%AE%97%E6%B3%95/02-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E9%99%84%E4%BB%B6/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220722120342.jpg)
以上图的数据为例。当转换为 count’数组后，我们从后往前遍历原数组。
1. 碰到了 3，也就是 003，找到 count[3]发现其对应的值为 5，也就是个位数小于等于 3 的数有五个，所以 003 只能排到最后，放到 help 数组的最后一位，此时 count[3]--，说明 003 已经排好了；
2. 遍历到 010，个位数为 0，对应的 count’[0]值为 1，说明个位数小于等于 1 的只有一个，所以 010 只能排到 help 的第一位，同时 count'[0]--，010 已经排好了；
3. 同理，我们可以排列好剩余的数字；
我们可以发现我们把数据转化为 count’就是入桶操作，我们把数据从 count’变位 help 时就是出桶。
在一般实现中，我们出桶从低到高开始遍历，和从高到低遍历其实本质差不多；而这个实现中，从倒序遍历 arr 就相当于模拟了出桶从高到低遍历的操作。**这利用了唯一性，由于更加靠后的元素是后入桶的，所以，倒序遍历时，他们一定是同个位数元素（更高位也同理）中的最大元素（最后出桶），所以理应被排在后面**，相当于我们 `help[count[j] - 1] = arr[k];` 这个操作就是找到了对应个位数所在的最后的位置；而 `count[j]--;` 就相当于找到了之后排除到这个位置，让下一个同个位数的元素放在其前面的位置。
