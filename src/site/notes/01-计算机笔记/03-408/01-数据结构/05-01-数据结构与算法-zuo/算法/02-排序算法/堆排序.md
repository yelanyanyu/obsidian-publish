---
{"dg-publish":true,"permalink":"/01/03-408/01/05-01-zuo//02//","tags":["personal/blog","algorithm/sorting"]}
---


# 概述
堆排序是一种利用堆数据结构进行排序的排序算法。其先将数组转换为大顶堆，再进行相应处理拿出最大值。其与选择排序的思想大同小异，但是时间复杂度和空间复杂度就要低很多。
时间复杂度：$O(N*log_2^N)$
空间复杂度：$O(1)$
我们将先简要介绍一下堆这种数据结构，为之后构建堆排序奠定基础。
***
# 堆
堆结构的本质就是完全二叉树。我们暂时不介绍二叉树。
有两种堆，大顶堆和小顶堆。前者的父节点的都大于等于其子节点，后者的父节点均小于等于其子节点。所以，我们不难发现，大顶堆的根节点永远是各结点的最大值，小顶堆的根节点永远是各结点中的最小值，于是根据这个性质，我们就有了排序的思路。
**总结，大根（小根）堆的条件为**：
	1. 完全二叉树；
	2. 任意父节点（非叶子节点）都大于其子节点；
**时间复杂度**：堆每一次调整（加入和弹出）操作的时间复杂度为 $O(logN)$。
***
# 思路
设完全二叉树与数组下标的对应关系为从上到下，从左到右，下标从 0 开始依次增大。
我们接下来假定所有的排序都是升序排序。我们会使用到大根堆。
1. 先将数组元素依次构建成大根堆；
2. 每次取其顶部元素（下标为 0，最大值）与其最后的子结点交换；
3. 让堆的容量减 1，即将最后一个元素拿出堆，后面不再对其进行操作，我们排序好了一个数；
4. 此时，该完全二叉树可能已经不是堆结构了，于是我们需要将其重新转化为大根堆；
5. 重新转化为大根堆后，重复 2-4，直到堆的容量为 0；
***
# 代码实现
0. 定义类 heapSort，以下是类的一些必要成员
```java
private static int heapSize = 0;  
private int[] heap;  
private final int limit;  
  
public heapSort(int limit) {  
    this.limit = limit;  
}
```
1. 定义 **heapInsert 函数**实现堆加入一个数，使得整颗树数保持为大根堆；
```java
private static void heapInsert(int[] arr, int index) {  
    while (arr[index] > arr[(index - 1) / 2]) {     //若是小顶堆，只需改成<  
        swap(arr, index, (index - 1) / 2);  
        index = (index - 1) / 2;  
    }  
}
``` 
**解读：**
	1. `index`表示子结点下标，`(index-1)/2`代表父结点的下标；
	2. 若新插入的结点比其父结点大（不满足大顶堆的定义），那么就与其父结点交换，接着继续往上比，直到找到符合条件的为止（比当前父结点小或者等于父结点），此时的完全二叉树仍然为大顶堆；
2. 定义 **swap 交换函数**来换取堆顶部元素和底部元素；
```java
private static void swap(int[] arr, int i, int j) {  
    int swap = arr[i];  
    arr[i] = arr[j];  
    arr[j] = swap;  
}
```
3. 定义 **heapify 函数**来使交换后的堆仍为大根堆：
```java
//功能：使得以index为根结点的堆为大根堆
//当弹出最大值时，使堆重新成为大顶堆  
//从index从下看，若比其孩子小则让index与最大的孩子交换;  
// 若还是小，再交换，直到成为叶子或者比所有孩子都要大  
private static void heapify(int[] arr, int index, int heapSize) {  
    int left = index * 2 + 1;   //index的左孩子  
    int largest = -1;  
    while (left < heapSize) {       //有左孩子，且不越界；右孩子有没有，越不越界，接下来看  
        //当有右孩子（右孩子不越界），且右孩子大于左孩子，则最大的孩子为右孩子  
        largest = left + 1 < heapSize && arr[left] < arr[left + 1] ? left + 1 : left;  
        //当父亲小于两个孩子的最大值时，交换那个最大值和父亲  
        largest = arr[largest] < arr[index] ? index : largest;  
        if (largest == index) {     //如果父节点就是最大的，那么就不用往下了  
            break;  
        }  
        swap(arr, index, largest);  
        index = largest;  
        left = index * 2 + 1;  
    }  
}
```
**解读：**
	1. 当左孩子越界时，右孩子肯定越界，左孩子越界就意味着，这个左孩子已经是之前排序好的数了，所以此时的大顶堆化就已经完成；
4. 写**排序主体**，调用各个方法实现堆排序功能：
```java
public void Sort(int[] arr) {  
    for (int i = 0; i < arr.length; i++) {      //将数组元素插入，使得成为一个大顶堆  
        heapInsert(arr, i);  
    }  
    heapSize = arr.length;  
    //依次交换顶部最大值和底部元素，同时让堆容量-1，从而达到选择最大值的效果
    //当堆容量为0时，数据就已经排序完毕了
    swap(arr, 0, --heapSize);  
    heapify(arr, 0, heapSize);  
    while (heapSize > 0) {  
        swap(arr, 0, --heapSize);  
        heapify(arr, 0, heapSize);  
    }  
}
```
***
# 加强堆
在很多时候，系统提供的堆并不能满足我们的需求，所以就需要我们定制一个功能特异的堆，这个堆就被称为“**加强堆**”。