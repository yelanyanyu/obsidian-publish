---
{"dg-publish":true,"permalink":"/01/01/01/acwing/05/032-1239/","tags":["blog"]}
---


# 题目描述
## 关系

## 内容
给定 $N$ 个整数 $A_1, A_2, … A_N$。

请你从中选出 $K$ 个数，使其乘积最大。

请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 $1000000009$ 的余数。

注意，如果 $X<0$，我们定义 $X$ 除以 $1000000009$ 的余数是负 ($-X$)除以 $1000000009$ 的余数，即：$0-((0-x) \% 1000000009)$

#### 输入格式

第一行包含两个整数 $N$ 和 $K$。

以下 $N$ 行每行一个整数 $A_i$。

#### 输出格式

输出一个整数，表示答案。

#### 数据范围

$1 \le K \le N \le 10^5$,  
$-10^5 \le A_i \le 10^5$

#### 输入样例 1：

```
5 3
-100000
-10000
2
100000
10000
```

#### 输出样例 1：

```
999100009
```

#### 输入样例 2：

```
5 3
-100000
-100000
-2
-100000
-100000
```

#### 输出样例 2：

```
-999999829
```
# 问题分析
## 最初思路
很显然，矛盾点就是有的时候负数的绝对值是很大的。但是选了负数又如何保证最后答案尽可能为正数呢？

什么时候选择的数最后只能为负数？

我们倾向于选择绝对值尽可能大的数，所以有如下流程：
 1. 如果当前结果为负数，那么下一个数只能为负数；
 2. 如果当前结果为正数，那么下一个数就选绝对值最大的数；
 3. 如果到了最后一个数，都无法凑为正数，那么我们就认为结果只能为负数；

为了更好的选择绝对值尽可能大的数，所以首先需要对数组进行排序。然后找出正负数的分界点；然后开始遍历。
## 思路分析

设每个人平均需要支付的钱数为 $\displaystyle x$，我们的目的是让每个人支付的钱数都尽可能靠近这个 x，具体来说，那么：
 1. 对于拥有钱数低于 x 的人，需要把自己所有的钱都拿出去来减小与平均值 x 的差距；
 2. 对于钱数大于 x 的人，只需要支付平均值就可以了；

但是，一个人少付了钱，那么总有人需要多付的？谁来多付呢？平摊。即我们可以重新计算平均值。例如假如第一个人的钱少于平均值，那么当这个人付完钱后，第二个以及之后的人就需要支付这些钱。

程序的贪心策略是这样的：
1. 计算出所有人应该支付的平均金额。
2. 将所有人拥有的钱从小到大排序。
3. 从最少的钱开始，如果这个人拥有的钱少于平均值，那么他就支付所有他拥有的钱。
4. 然后重新计算剩下的人的新平均值。
5. 如果下一个人的钱也少于新的平均值，那么他也支付所有他拥有的钱，再次更新剩下的人的平均值。
6. 重复这个过程，直到所有人都支付了钱。

***
**证明：**



## 执行流程设计
1. 排序；
2. 执行主逻辑；
# 总结

# 代码实现
```c++
#include <bits/stdc++.h>
using namespace std;

#define double long double

const int N = 5e5 + 10, eps = 1e-8;
int n; double s;
int a[N]; double b[N];

int main()
{
    scanf("%d%llf", &n, &s);
    
    for (int i = 0; i < n; i++) {scanf("%d", &a[i]);}
    
    sort(a, a + n);
    
    double cur_avg = 1.0 * s / n, sum_b = 0; 
    double mius = eps;
    for (int i = 0; i < n; i++) {
        cur_avg = 1.0 * s / (n - i);
        
        if (a[i] <= cur_avg) {
            b[i] = a[i];
        } else {
            b[i] = cur_avg;
        }
        
        sum_b += b[i];
        s -= b[i];
    }
    
    double avg_b = sum_b / n, tmp = 0;
    for (int i = 0; i < n; i++) {
        tmp += (b[i] - avg_b) * (b[i] - avg_b);
    }
    
    double res = sqrt(tmp / n);
    printf("%.4llf", res);
    return 0;
}
```