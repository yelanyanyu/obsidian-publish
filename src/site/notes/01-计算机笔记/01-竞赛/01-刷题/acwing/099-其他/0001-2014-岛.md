---
{"dg-publish":true,"permalink":"/01-计算机笔记/01-竞赛/01-刷题/acwing/099-其他/0001-2014-岛/","tags":["personal/blog","algorithm/离散化","algorithm/差分","algorithm/acwing","algorithm/sorting"]}
---

[2014. 岛 - AcWing题库](https://www.acwing.com/problem/content/2016/)
# 题目描述
## 关系

## 内容
每当下雨时，农夫约翰的田地总是被洪水淹没。

由于田地不是完全水平的，所以一些地方充满水后，留下了许多被水隔开的“岛”。

约翰的田地被描述为由 $N$ 个连续高度值 $H_1,…,H_N$ 指定的一维场景。

假设该场景被无限高的围墙包围着，请考虑暴雨期间发生的情况：

最低处首先被水覆盖，形成一些不连贯的岛，随着水位的不断上升，这些岛最终都会被覆盖。

一旦水位等于一块田地的高度，那块田地就被认为位于水下。

![fig_islands.png](https://cdn.acwing.com/media/article/image/2020/06/24/19_8c986a0cb5-fig_islands.png)

上图显示了一个示例：在左图中，我们只加入了刚好超过 $1$ 单位的水，此时剩下 $4$ 个岛（最大岛屿剩余数量），而在右图中，我们共加入了 $7$ 单位的水，此时仅剩下 $2$ 个岛。

请计算，暴风雨期间我们能在某个时间点看到的最大岛屿数量。

水会一直上升到所有田地都在水下。

#### 输入格式

第一行包含整数 $N$。

接下来 $N$ 行，每行包含一个整数表示 $H_i$。

#### 输出格式

输出暴风雨期间我们能在某个时间点看到的最大岛屿数量。

#### 数据范围

$1 \le N \le 10^5$,  
$1 \le H_i \le 10^9$

#### 输入样例：

```
8
3
5
2
3
1
4
2
3
```

#### 输出样例：

```
4
```
# 问题分析
## 最初思路
我们首先要从最小高度的山开始枚举，对于每一座山，我们都去判断一下当前还有几座山，最后取最大的就行了。

但是难点就是如何判断当前还有几座山。其实就是遍历所有的山：
 1. 如果当前山的高度小于水高，那么就下一个；
 2. 如果当前山的高度大于水，那么就看看其邻居有多少是高于水的；

当雨水刚好淹没第一座山，那么山的数量应该从 1 变为了 2，第一座山在两周除外。
刚好淹没第二座山，山的数量恐怕难以确定。

## 思路分析
这道题目的意思可能会有点难理解。这里的柱子我们应该看成一个整体。当雨还没有下的时候，应该只有一座山，当雨下了无穷久的时候，应该一座山都没有。

如果有两个 H 一样且相邻，那么就可以视为一座山。
## 执行流程设计

# 总结

# 代码实现
```

```